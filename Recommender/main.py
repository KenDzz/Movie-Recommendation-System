# --------- credits.csv ----------
# id - A unique identifier for each movie.
# cast - The name of lead and supporting actors.
# crew - The name of Director, Editor, Composer, Writer etc.

# ------- movies_metadata.csv ---------
# budget - The budget in which the movie was made.
# genre - The genre of the movie, Action, Comedy ,Thriller etc.
# homepage - A link to the homepage of the movie.
# id : A unique identifier for each movie.
# keywords - The keywords or tags related to the movie.
# original_language - The language in which the movie was made.
# original_title - The title of the movie before translation or adaptation.
# overview - A brief description of the movie.
# popularity - A numeric quantity specifying the movie popularity.
# production_companies - The production house of the movie.
# production_countries - The country in which it was produced.
# release_date - The date on which it was released.
# revenue - The worldwide revenue generated by the movie.
# runtime - The running time of the movie in minutes.
# status - "Released" or "Rumored".
# tagline - Movie's tagline.
# title - Title of the movie.
# vote_average - average ratings the movie recieved.
# vote_count - the count of votes recieved.

import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer, CountVectorizer
from sklearn.metrics.pairwise import linear_kernel, cosine_similarity
import warnings; warnings.simplefilter('ignore')

#Define a TF-IDF Vectorizer Object. Remove all english stop words such as 'the', 'a'
tfidf = TfidfVectorizer(stop_words='english')

count = CountVectorizer(stop_words='english')

def weighted_rating(x, m, C):
    v = x['vote_count']
    R = x['vote_average']
    # Calculation based on the IMDB formula
    return (v/(v+m) * R) + (m/(m+v) * C)


def content_based_recommender(title, dataframe):
    # Construct the required TF-IDF matrix by fitting and transforming the data
    tfidf_matrix = tfidf.fit_transform(dataframe['overview'])
    # Output the shape of tfidf_matrix
    cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)
    # title - index olusturma
    indices = pd.Series(dataframe.index, index=dataframe['title'])
    indices = indices[~indices.index.duplicated(keep='last')]
    # Get the index of the movie that matches the title
    movie_index = indices[title]
    print(movie_index)

    similarity_scores = pd.DataFrame(cosine_sim[movie_index], columns=['scoretfidf'])

    movie_indices = similarity_scores.sort_values(by='scoretfidf', ascending=False)[1:13].index
    return dataframe.iloc[movie_indices]


def get_CreditsGenresKeywordsrecommendations(title, df):

    count_matrix = count.fit_transform(df['soup'])
    # Output the shape of tfidf_matrix
    cosine_sim2 = cosine_similarity(count_matrix, count_matrix)

    indices2 = pd.Series(df.index, index=df['title']).drop_duplicates()

    # Get the index of the movie that matches the title
    idx2 = indices2[title]

    sim_scores2 = pd.DataFrame(cosine_sim2[idx2], columns=['scoreCount'])
    movie_indices2 = sim_scores2.sort_values(by='scoreCount', ascending=False)[1:13].index

    # Return the top 100 most similar movies
    return df.iloc[movie_indices2]




def Movie_Recommendations(title,df):
    Result1 = content_based_recommender(title, df)
    Result2 = get_CreditsGenresKeywordsrecommendations(title, df)
    Result = Result1.append(Result2, ignore_index = True)


    # average
    C = Result['vote_average'].mean()
    # Luot binh chon cao hon 90% luot binh chon con lai
    M = Result['vote_count'].quantile(0.9)
    # Get Movie > M
    #q_movies = Result.copy().loc[Result['vote_count'] >= M]
    Result['score'] = Result.apply(weighted_rating, axis=1, args=(C,M,))
    # Sort movies based on score calculated above
    q_movies = Result.sort_values('score', ascending=False)
    return q_movies

#print(Movie_Recommendations('The Dark Knight Rises'))