# --------- credits.csv ----------
# id - A unique identifier for each movie.
# cast - The name of lead and supporting actors.
# crew - The name of Director, Editor, Composer, Writer etc.

# ------- movies_metadata.csv ---------
# budget - The budget in which the movie was made.
# genre - The genre of the movie, Action, Comedy ,Thriller etc.
# homepage - A link to the homepage of the movie.
# id : A unique identifier for each movie.
# keywords - The keywords or tags related to the movie.
# original_language - The language in which the movie was made.
# original_title - The title of the movie before translation or adaptation.
# overview - A brief description of the movie.
# popularity - A numeric quantity specifying the movie popularity.
# production_companies - The production house of the movie.
# production_countries - The country in which it was produced.
# release_date - The date on which it was released.
# revenue - The worldwide revenue generated by the movie.
# runtime - The running time of the movie in minutes.
# status - "Released" or "Rumored".
# tagline - Movie's tagline.
# title - Title of the movie.
# vote_average - average ratings the movie recieved.
# vote_count - the count of votes recieved.

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats
from ast import literal_eval
from sklearn.feature_extraction.text import TfidfVectorizer, CountVectorizer
from sklearn.metrics.pairwise import linear_kernel, cosine_similarity
from nltk.stem.snowball import SnowballStemmer
from nltk.stem.wordnet import WordNetLemmatizer
from nltk.corpus import wordnet
#from surprise import Reader, Dataset, SVD, evaluate

import warnings; warnings.simplefilter('ignore')

def weighted_rating(x, m, C):
    v = x['vote_count']
    R = x['vote_average']
    # Calculation based on the IMDB formula
    return (v/(v+m) * R) + (m/(m+v) * C)


def get_recommendations(title, df):
    # Define a TF-IDF Vectorizer Object. Remove all english stop words such as 'the', 'a'
    tfidf = TfidfVectorizer(stop_words='english')
    # Replace NaN with an empty string
    df['overview'] = df['overview'].fillna('')
    # Construct the required TF-IDF matrix by fitting and transforming the data
    tfidf_matrix = tfidf.fit_transform(df['overview'])
    # Output the shape of tfidf_matrix
    cosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)
    indices = pd.Series(df.index, index=df['title']).drop_duplicates()

    # Get the index of the movie that matches the title
    idx = indices[title]
    # Get the pairwsie similarity scores of all movies with that movie
    sim_scores = list(enumerate(cosine_sim[idx]))
    # Sort the movies based on the similarity scores
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    # Get the scores of the 10 most similar movies
    sim_scores = sim_scores[1:101]
    # Get the movie indices
    movie_indices = [i[0] for i in sim_scores]
    # Return the top 10 most similar movies
    return df.iloc[movie_indices]


def Movie_Recommendations(title,df):
    Result = get_recommendations(title, df)
    # average
    C = Result['vote_average'].mean()
    # Luot binh chon cao hon 90% luot binh chon con lai
    M = Result['vote_count'].quantile(0.9)
    # Get Movie > M
    q_movies = Result.copy().loc[Result['vote_count'] >= M]
    q_movies['score'] = q_movies.apply(weighted_rating, axis=1, args=(C,M,))
    # Sort movies based on score calculated above
    q_movies = q_movies.sort_values('score', ascending=False)
    return q_movies

#print(Movie_Recommendations('The Dark Knight Rises'))